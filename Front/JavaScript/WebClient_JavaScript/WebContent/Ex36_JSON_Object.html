<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script type="text/javascript">
	/* 
	​	자바 설계도(클래스) => 재사용성
	class Product{
			private String carname="pony";
			public Product(){}
			public Product(String carname){
				this.carname= carname;
			}
			public void print(){
				System.out.println(this.carname);
			}
	}

	메모리 load ... (new)
	Product p = new Product();
	Product p2 = new Product("pony2");

	p.print();
	p2.print();
	/////////////////////////////////////////////////////

	javaScript >> 객체지향언어(OOP)

	클래스 정의 3가지 방법

	1. 프로토타입 방식 :  일반적인 클래스 제작 방법
					  인스턴스마다 공통된 메서드를 공유해서 사용하는 장점 
	               	  Jquery 도 prototype 방식으로 설계

	function 클래스이름() {
						this.프로퍼티1 = 초기값;
						this.프로퍼티2 = 초기값;
	}

	클래스이름.prototype.메서드1 = function() {
	}
	클래스이름.prototype.메서드2 = function() {
	}

	var 인스턴스 = new 클래스이름(); 
	var carObj = new Car();
	var carObj2 = new Car();
	var carObj3 = new Car();

	​

	​

	2. 함수 방식 : 간단한 클래스 제작 시 사용 
	인스턴스마다 메서드가 독립적으로 만들어지는 단점
	 ** 클래스 :  function Car(){ this.name = , this.age=}
	 ** 함수 :   function car(){}

	function 클래스이름() {
				this.프로퍼티1 = 초기값;
				this.프로퍼티2 = 초기값;
				this.메서드1 = function() {

				}
				this.메서드2 = function() {

				}
	}

	var 인스턴스 = new 클래스이름(); 
	var carObj = new Car();
	var carObj2 = new Car();
	var carObj3 = new Car();

	​

	​

	​
	 *****************
	3. 리터럴 방식 : 
	   클래스 만드는 용도는 아니며 주로 여러개의 매개변수를 그룹으로 묶어 함수의 매개변수로 보낼때
	   정의와 함께 인스턴스가 만들어지는 장점이 있음 단 인스턴스는 오직 하나
	  (초보자에게도 중요 ^^)
	​

	4. ECMA6 버전부터 : class 키워드 제공
		class Person {
						constructor(name) {
						this._name = name;
	    				}
						sayHi() {
									console.log(`Hi! ${this._name}`);
								}
		}

	​

	[ javascript 객체 생성 ]
	1.오브젝트 리터럴 방식 (객체를 만드는 방법): 클래스 생성과 동시에 객체가 만들어 져요
	1.1 리터럴 방식 >> 제일 간단한 방법 > var obj = {}; //var objarr = [] 배열 
	1.2 JSON 표기 : {} >> JSON: JavaScript Object Notation

	ex) var myObj = { "name":"John", "age":31, "city":"New York" };

	TIP) JSON >> XML (텍스트 기반의 형식화된 문서 제공)
	XML :이기종간의 데이터 호환 (한 때는 서점 : xml webservice)

	다른 이야기 >> 
	JSON
	객체지향언어 장점 : 설계도 (재사용성)
	 *오브젝트 리터럴 방식 : 재사용을 지원하는 않는다 
	 *설계도를 생성과 동시에 객체 생성(장점 : 편하고 , 빠르다 )
	 *설계도를 미리 만들어 놓고 재사용하는 방식은 아니다
	 *설계도당 하나의 객체만 생성 사용 (only object)
	
	
	리터럴 방식 > 선언과 동시에 인스턴스 자동 생성
	var 인스턴스 = {}
	특징 : 생성자 존재하지 않는다.
	프로퍼티와 메서드만 정의 가능
	단점 : 객체 하나 생성(재사용성 없다) 
	접근방법 : 인스턴스이름.자원 >> product2.제품명 
	​
	var product = {};  //Product p = new Product();

	var product2 = {제품명:'사과',년도:'2018',원산지:'대구'};

	var 인스턴스 ={
					프로퍼티:초기값,
					프로퍼티:초기값,
					.....
					메서드:function(){},
					메서드:function(){}....
	}
	 */
	let product = {
		제품명 : '사과',
		년도 : '2000',
		원산지 : '대구'
	};

	console.log(product);
	document.write(product.제품명 + "<br>");
	document.write(product.년도 + "<br>");
	document.write(product.원산지 + "<br>");
	document.write(product.toString() + "<br>");

	//{객체}
	let person = {
		name : "홍길동",
		addr : "서울시 강남구 역삼동",
		eat : function(food) {
			document.write(this.name + "/ " + this.addr + "/ " + food + "냠냠")
		}
	};

	document.write("<hr>");
	person.eat("사과"); // 함수 호출

	//1. 속성 제거 기능
	//product = {제품명:'사과' , 년도:'2000' , 원산지:'대구'};
	//Map 비슷
	delete (product.년도);
	console.log(product);

	for ( let key in product) {
		console.log("key : " + key);
		console.log(product[key]);
	}

	for ( let key in person) {
		console.log("key :" + key + "=" + person[key]);
	}
	
	//json 객체 활용 ( xml )
	//외부 API 활용 ( 서울시 공공데이터, 대법원 판례, 날씨 정보 )
	
	let Member={}; //빈 객체 
	Member.name = "hong"; //Member = { name : "hong" }, 속성 추가
	console.log(Member);
	console.log(Member.name);
	
	Member.age = 100;
	
	//함수도 추가가능
	Member.print = function() {
		document.write("<br>" + this.name + "/" + this.age );
	}
	
	Member.print();
	
	//POINT : 객체가 객체를 가질 수 있다, 객체가 배열을 가질 수 있다. 
	//java 에서도 class Member { Car car = new Car(); int[] intarr = new int[5]}
	let Grade = {
			"list" : {
				"hong" : 10,
				"kim" : 20,
				"park" : 30
			},
			"show" : function() {
				for(let key in this.list ) {
					document.write(key + " : " + this.list[key] + "<br>");
				}
			}
	}
	Grade.show();
	document.write("<hr>");
	
	let listobj = Grade.list; //list 의 value는 객체를 가지고 있다. 그 객체의 주소를 가진다?
	document.write(listobj.kim + "<br>");
	
	for(let key in listobj) {
		document.write(key + " : " + listobj[key] + "<br>");
	}
	</script>
</head>
<body>
</body>
</html>